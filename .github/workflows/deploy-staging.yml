name: Deploy to AWS Staging

on:
  push:
    branches: [cicd-pipeline-setup, main]
  workflow_dispatch:
    inputs:
      run_migrations:
        description: 'Force run database schema sync (uses db push for existing databases)'
        required: false
        default: 'true'
        type: boolean

env:
  AWS_REGION: ap-southeast-1
  ECS_CLUSTER: namecard-cluster-staging
  ECS_SERVICE: namecard-api-staging

jobs:
  test:
    name: Run Tests
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Generate Prisma client
        run: |
          cd packages/api
          npm run db:generate

      - name: Run linting
        run: npx turbo run lint --filter="@namecard/*"

      - name: Run type checking
        run: npx turbo run type-check --filter="@namecard/*"

      - name: Run tests
        run: npx turbo run test --filter="@namecard/*"

  build-and-deploy:
    name: Build and Deploy
    runs-on: ubuntu-latest
    needs: test
    if: github.ref == 'refs/heads/cicd-pipeline-setup' || github.ref == 'refs/heads/main'
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Build application
        run: npm run build

      - name: Validate and deploy secrets
        run: |
          echo "🔐 Validating and deploying secrets for staging environment..."
          # Check if secrets exist and are accessible
          aws secretsmanager get-secret-value --secret-id namecard/api/staging --region ${{ env.AWS_REGION }} --query 'SecretString' --output text > /dev/null
          aws secretsmanager get-secret-value --secret-id namecard/database/staging --region ${{ env.AWS_REGION }} --query 'SecretString' --output text > /dev/null
          echo "✅ All required secrets are accessible"

      - name: Wait for stable CloudFormation stack
        run: |
          echo "🔍 Checking CloudFormation stack status before deployment..."
          
          STACK_STATUS=$(aws cloudformation describe-stacks --stack-name NameCardProd-staging --region ${{ env.AWS_REGION }} --query 'Stacks[0].StackStatus' --output text)
          echo "Current stack status: $STACK_STATUS"
          
          if [[ "$STACK_STATUS" == *"IN_PROGRESS"* ]]; then
            echo "⏳ Stack is in $STACK_STATUS state - waiting for completion..."
            
            # Wait for stack to reach stable state (max 20 minutes)
            echo "⌛ Waiting for stack to reach stable state (max 20 minutes)..."
            timeout 1200 aws cloudformation wait stack-update-complete --stack-name NameCardProd-staging --region ${{ env.AWS_REGION }} || {
              echo "⚠️ Stack update didn't complete in 20 minutes, checking current status..."
              FINAL_STATUS=$(aws cloudformation describe-stacks --stack-name NameCardProd-staging --region ${{ env.AWS_REGION }} --query 'Stacks[0].StackStatus' --output text)
              echo "Final status: $FINAL_STATUS"
              
              if [[ "$FINAL_STATUS" == *"ROLLBACK_COMPLETE"* ]] || [[ "$FINAL_STATUS" == *"UPDATE_COMPLETE"* ]] || [[ "$FINAL_STATUS" == *"CREATE_COMPLETE"* ]]; then
                echo "✅ Stack reached stable state: $FINAL_STATUS"
              else
                echo "❌ Stack is still in unstable state: $FINAL_STATUS"
                echo "🔍 Recent stack events:"
                aws cloudformation describe-stack-events --stack-name NameCardProd-staging --region ${{ env.AWS_REGION }} --query 'StackEvents[:5].[Timestamp,LogicalResourceId,ResourceStatus,ResourceStatusReason]' --output table
                exit 1
              fi
            }
          else
            echo "✅ Stack is in stable state: $STACK_STATUS"
          fi

      - name: Deploy infrastructure updates
        run: |
          cd infrastructure
          npm ci
          
          echo "🏗️ Deploying infrastructure updates with health check configuration..."
          
          # Force update to ensure health check configuration is applied
          npx cdk deploy NameCardProd-staging --context environment=staging --require-approval never --outputs-file outputs.json --force
          
          echo "✅ Infrastructure deployment completed"
          
          # Wait a moment for infrastructure changes to propagate
          sleep 30

      - name: Ensure PERPLEXITY_API_KEY exists in secrets
        run: |
          echo "🔐 Ensuring PERPLEXITY_API_KEY exists in API secrets..."
          
          # Get the current API secret value
          echo "📋 Retrieving current secret..."
          CURRENT_SECRET=$(aws secretsmanager get-secret-value --secret-id namecard/api/staging --region ${{ env.AWS_REGION }} --query 'SecretString' --output text)
          
          # Check if PERPLEXITY_API_KEY already exists
          EXISTING_KEY=$(echo "$CURRENT_SECRET" | jq -r '.PERPLEXITY_API_KEY // empty')
          
          if [ -z "$EXISTING_KEY" ] || [ "$EXISTING_KEY" = "null" ]; then
            echo "⚠️ PERPLEXITY_API_KEY missing from secret - adding it..."
            
            # Add PERPLEXITY_API_KEY to the existing secret
            UPDATED_SECRET=$(echo "$CURRENT_SECRET" | jq '. + {"PERPLEXITY_API_KEY": "pplx-dummy-key-replace-in-console"}')
            
            # Update the secret in AWS Secrets Manager
            aws secretsmanager update-secret \
              --secret-id namecard/api/staging \
              --secret-string "$UPDATED_SECRET" \
              --region ${{ env.AWS_REGION }}
            
            echo "✅ Added PERPLEXITY_API_KEY to API secrets"
          else
            echo "✅ PERPLEXITY_API_KEY already exists in secret: ${EXISTING_KEY:0:10}..."
          fi
          
          # Final verification that the key exists
          echo "🔍 Final verification..."
          FINAL_CHECK=$(aws secretsmanager get-secret-value --secret-id namecard/api/staging --region ${{ env.AWS_REGION }} --query 'SecretString' --output text | jq -r '.PERPLEXITY_API_KEY')
          if [ "$FINAL_CHECK" != "null" ] && [ -n "$FINAL_CHECK" ]; then
            echo "✅ PERPLEXITY_API_KEY confirmed in secrets: ${FINAL_CHECK:0:10}..."
            echo "📊 All secret keys:"
            aws secretsmanager get-secret-value --secret-id namecard/api/staging --region ${{ env.AWS_REGION }} --query 'SecretString' --output text | jq -r 'keys[]'
          else
            echo "❌ PERPLEXITY_API_KEY verification failed - ECS tasks will fail!"
            echo "🔍 Current secret keys:"
            aws secretsmanager get-secret-value --secret-id namecard/api/staging --region ${{ env.AWS_REGION }} --query 'SecretString' --output text | jq -r 'keys[]'
            exit 1
          fi

      - name: Detect schema changes
        id: schema_changes
        run: |
          echo "🔍 Detecting database schema changes..."
          
          # Check if prisma schema or migrations have changed
          SCHEMA_CHANGED=$(git diff --name-only HEAD^ HEAD | grep -E "(packages/api/prisma/|\.prisma$)" || echo "")
          
          if [ -n "$SCHEMA_CHANGED" ]; then
            echo "schema_changed=true" >> $GITHUB_OUTPUT
            echo "📊 Schema changes detected:"
            echo "$SCHEMA_CHANGED"
          else
            echo "schema_changed=false" >> $GITHUB_OUTPUT
            echo "✅ No schema changes detected"
          fi

      - name: Run database schema sync
        if: steps.schema_changes.outputs.schema_changed == 'true' || github.event.inputs.run_migrations != 'false'
        run: |
          echo "🔄 Syncing database schema via ECS task..."
          
          # Get database credentials from AWS Secrets Manager
          DB_SECRET=$(aws secretsmanager get-secret-value --secret-id namecard/database/staging --region ${{ env.AWS_REGION }} --query 'SecretString' --output text)
          DB_HOST=$(echo "$DB_SECRET" | jq -r '.host')
          DB_USER=$(echo "$DB_SECRET" | jq -r '.username') 
          DB_PASS=$(echo "$DB_SECRET" | jq -r '.password')
          DB_NAME=$(echo "$DB_SECRET" | jq -r '.dbname')
          
          DATABASE_URL="postgresql://${DB_USER}:${DB_PASS}@${DB_HOST}:5432/${DB_NAME}?sslmode=require"
          
          # URL encode the password
          ENCODED_DB_PASS=$(echo "$DB_PASS" | python3 -c "import sys, urllib.parse; print(urllib.parse.quote(sys.stdin.read().strip(), safe=''))")
          ENCODED_DATABASE_URL="postgresql://${DB_USER}:${ENCODED_DB_PASS}@${DB_HOST}:5432/${DB_NAME}?sslmode=require"
          
          echo "Running ECS schema sync task..."
          
          # Use 'db push' for existing databases to avoid P3005 migration baseline issues
          # This command synchronizes the database schema without migration history tracking
          TASK_ARN=$(aws ecs run-task \
            --cluster ${{ env.ECS_CLUSTER }} \
            --task-definition NameCardProdstagingAPIServiceTaskDef909B2074 \
            --launch-type FARGATE \
            --network-configuration 'awsvpcConfiguration={subnets=["subnet-0403b9e9f399616f7","subnet-04b6efe73095e9358"],securityGroups=["sg-03b3f7a95865bc00a"],assignPublicIp=ENABLED}' \
            --overrides "{\"containerOverrides\":[{\"name\":\"namecard-api\",\"command\":[\"sh\",\"-c\",\"cd /app/packages/api && npx prisma db push --accept-data-loss\"],\"environment\":[{\"name\":\"DATABASE_URL\",\"value\":\"$ENCODED_DATABASE_URL\"}]}]}" \
            --region ${{ env.AWS_REGION }} \
            --query 'tasks[0].taskArn' --output text)
          
          echo "Schema sync task started: $TASK_ARN"
          TASK_ID=$(echo "$TASK_ARN" | sed 's/.*\///')
          
          # Wait for task to complete
          echo "⏳ Waiting for schema sync task to complete..."
          aws ecs wait tasks-stopped --cluster ${{ env.ECS_CLUSTER }} --tasks "$TASK_ID" --region ${{ env.AWS_REGION }}
          
          # Check task exit code
          EXIT_CODE=$(aws ecs describe-tasks --cluster ${{ env.ECS_CLUSTER }} --tasks "$TASK_ID" --region ${{ env.AWS_REGION }} --query 'tasks[0].containers[0].exitCode' --output text)
          
          if [ "$EXIT_CODE" = "0" ]; then
            echo "✅ Database schema sync completed successfully!"
            
            # Get sync logs
            LOG_STREAM="namecard-api/namecard-api/$TASK_ID"
            echo "📋 Schema sync logs:"
            aws logs get-log-events --log-group-name "/namecard/api-service/staging" --log-stream-name "$LOG_STREAM" --region ${{ env.AWS_REGION }} --query 'events[].message' --output text 2>/dev/null || echo "Log stream not available yet"
          else
            echo "❌ Database schema sync failed! Exit code: $EXIT_CODE"
            
            # Get error logs
            LOG_STREAM="namecard-api/namecard-api/$TASK_ID"
            echo "📋 Schema sync error logs:"
            aws logs get-log-events --log-group-name "/namecard/api-service/staging" --log-stream-name "$LOG_STREAM" --region ${{ env.AWS_REGION }} --query 'events[].message' --output text 2>/dev/null || echo "Log stream not available yet"
            exit 1
          fi

      - name: Update ECS service
        run: |
          echo "🔄 Updating ECS service with verified secrets..."
          
          # Pre-deployment secret verification
          echo "🔍 Pre-deployment secret verification..."
          SECRET_KEYS=$(aws secretsmanager get-secret-value --secret-id namecard/api/staging --region ${{ env.AWS_REGION }} --query 'SecretString' --output text | jq -r 'keys[]')
          echo "Available secret keys:"
          echo "$SECRET_KEYS"
          
          # Ensure PERPLEXITY_API_KEY is present
          if echo "$SECRET_KEYS" | grep -q "PERPLEXITY_API_KEY"; then
            echo "✅ PERPLEXITY_API_KEY confirmed present before ECS deployment"
          else
            echo "❌ PERPLEXITY_API_KEY still missing! Cannot proceed with ECS deployment."
            exit 1
          fi
          
          # Wait for secrets to propagate before forcing new deployment
          echo "⏳ Waiting 60 seconds for secrets to propagate..."
          sleep 60
          
          # Force new deployment to pick up updated secrets
          echo "🚀 Forcing new ECS deployment with all required secrets..."
          aws ecs update-service \
            --cluster ${{ env.ECS_CLUSTER }} \
            --service ${{ env.ECS_SERVICE }} \
            --force-new-deployment
          
          echo "✅ ECS service update initiated - new tasks will use updated secrets"
          
          echo "⏳ Waiting for service to stabilize (max 15 minutes)..."
          
          # Use timeout command to limit wait time to 15 minutes (900 seconds)
          timeout 900 aws ecs wait services-stable \
            --cluster ${{ env.ECS_CLUSTER }} \
            --services ${{ env.ECS_SERVICE }} || {
              echo "⚠️ Service stabilization timeout or failure detected!"
              
              # Check service status for debugging
              echo "🔍 Checking service status..."
              SERVICE_STATUS=$(aws ecs describe-services \
                --cluster ${{ env.ECS_CLUSTER }} \
                --services ${{ env.ECS_SERVICE }} \
                --query 'services[0].status' --output text)
              echo "Service status: $SERVICE_STATUS"
              
              # Check task health status
              echo "🔍 Checking task health..."
              TASK_ARNS=$(aws ecs list-tasks \
                --cluster ${{ env.ECS_CLUSTER }} \
                --service-name ${{ env.ECS_SERVICE }} \
                --query 'taskArns[]' --output text)
              
              for TASK_ARN in $TASK_ARNS; do
                TASK_ID=$(echo "$TASK_ARN" | sed 's/.*\///')
                HEALTH_STATUS=$(aws ecs describe-tasks \
                  --cluster ${{ env.ECS_CLUSTER }} \
                  --tasks "$TASK_ID" \
                  --query 'tasks[0].healthStatus' --output text)
                LAST_STATUS=$(aws ecs describe-tasks \
                  --cluster ${{ env.ECS_CLUSTER }} \
                  --tasks "$TASK_ID" \
                  --query 'tasks[0].lastStatus' --output text)
                echo "Task $TASK_ID: Status=$LAST_STATUS, Health=$HEALTH_STATUS"
              done
              
              # Check recent service events for errors
              echo "🔍 Recent service events:"
              aws ecs describe-services \
                --cluster ${{ env.ECS_CLUSTER }} \
                --services ${{ env.ECS_SERVICE }} \
                --query 'services[0].events[:3].[createdAt,message]' --output table
              
              echo "❌ Service failed to stabilize within 15 minutes. Continuing with manual verification..."
            }
          
          echo "✅ Service update completed (may still be stabilizing)"

      - name: Verify deployment
        run: |
          # Health endpoint is at /health (root level) - not proxied by CloudFront
          # Use direct load balancer URL for health check since CloudFront only forwards /api/*
          HEALTH_URL="http://NameCa-APISe-N5y96ivnIVEm-949793622.ap-southeast-1.elb.amazonaws.com/health"
          
          # API endpoints are accessible via CloudFront
          API_BASE_URL="https://d1357e576dd65p.cloudfront.net/api"
          
          echo "🔍 Health check URL: $HEALTH_URL"
          echo "🔍 API base URL: $API_BASE_URL"
          
          # First, check if any tasks are running
          echo "🔍 Checking running tasks..."
          RUNNING_TASKS=$(aws ecs list-tasks \
            --cluster ${{ env.ECS_CLUSTER }} \
            --service-name ${{ env.ECS_SERVICE }} \
            --desired-status RUNNING \
            --query 'taskArns | length(@)' --output text)
          echo "Running tasks: $RUNNING_TASKS"
          
          if [ "$RUNNING_TASKS" = "0" ]; then
            echo "❌ No running tasks found! Checking stopped tasks..."
            aws ecs list-tasks \
              --cluster ${{ env.ECS_CLUSTER }} \
              --service-name ${{ env.ECS_SERVICE }} \
              --desired-status STOPPED \
              --query 'taskArns[:3]' --output text | while read TASK_ARN; do
                if [ -n "$TASK_ARN" ]; then
                  TASK_ID=$(echo "$TASK_ARN" | sed 's/.*\///')
                  echo "🔍 Stopped task $TASK_ID:"
                  aws ecs describe-tasks \
                    --cluster ${{ env.ECS_CLUSTER }} \
                    --tasks "$TASK_ID" \
                    --query 'tasks[0].{StoppedReason:stoppedReason,ExitCode:containers[0].exitCode}' --output table
                fi
              done
          fi
          
          # Health check with retry and better error reporting
          echo "🏥 Running health check..."
          for i in {1..10}; do
            response=$(curl -s -o /dev/null -w "%{http_code}" "$HEALTH_URL" || echo "000")
            
            if [ "$response" = "200" ]; then
              echo "✅ Deployment successful! API is healthy."
              echo "🚀 Health check passed at: $HEALTH_URL"
              echo "📊 Testing API info endpoint via CloudFront..."
              
              # Test database connectivity by checking API info endpoint via CloudFront
              info_response=$(curl -s -o /dev/null -w "%{http_code}" "$API_BASE_URL/v1/" || echo "000")
              if [ "$info_response" = "200" ]; then
                echo "✅ Database connectivity verified - API endpoints responding via CloudFront"
                
                # Get API info for final verification
                echo "📋 API Info:"
                curl -s "$API_BASE_URL/v1/" | head -10
              else
                echo "⚠️  API info endpoint returned: $info_response"
              fi
              exit 0
            else
              echo "⏱️  Attempt $i/10: HTTP status $response, waiting 15 seconds..."
              
              if [ "$i" = "5" ]; then
                echo "🔍 Mid-check debugging - checking task status..."
                TASK_ARNS=$(aws ecs list-tasks \
                  --cluster ${{ env.ECS_CLUSTER }} \
                  --service-name ${{ env.ECS_SERVICE }} \
                  --query 'taskArns[:2]' --output text)
                
                for TASK_ARN in $TASK_ARNS; do
                  if [ -n "$TASK_ARN" ]; then
                    TASK_ID=$(echo "$TASK_ARN" | sed 's/.*\///')
                    echo "🔍 Task $TASK_ID status:"
                    aws ecs describe-tasks \
                      --cluster ${{ env.ECS_CLUSTER }} \
                      --tasks "$TASK_ID" \
                      --query 'tasks[0].{LastStatus:lastStatus,HealthStatus:healthStatus,DesiredStatus:desiredStatus}' --output table
                  fi
                done
              fi
              
              sleep 15
            fi
          done
          
          echo "❌ Health check failed after 10 attempts. Final HTTP status: $response"
          echo "🔍 Final debugging information:"
          
          # Show service status
          aws ecs describe-services \
            --cluster ${{ env.ECS_CLUSTER }} \
            --services ${{ env.ECS_SERVICE }} \
            --query 'services[0].{Status:status,RunningCount:runningCount,PendingCount:pendingCount,DesiredCount:desiredCount}' --output table
          
          exit 1

      - name: Notify deployment status
        if: always()
        run: |
          if [ "${{ job.status }}" = "success" ]; then
            echo "🎉 Deployment to staging completed successfully!"
          else
            echo "💥 Deployment failed. Please check the logs."
          fi