name: Secret Management Workflow

on:
  push:
    branches: [main]
    paths:
      - 'infrastructure/lib/secrets-stack.ts'
      - 'infrastructure/lib/production-stack.ts'
      - 'infrastructure/config/**'
      - '.github/workflows/secret-management.yml'
      - '.github/workflows/deploy-staging.yml'
  pull_request:
    branches: [main]
    paths:
      - 'infrastructure/lib/secrets-stack.ts'
      - 'infrastructure/lib/production-stack.ts'
      - 'infrastructure/config/**'
      - '.github/workflows/secret-management.yml'
  schedule:
    # Daily health check at 2 AM UTC
    - cron: '0 2 * * *'
  workflow_call:
    inputs:
      environment:
        description: 'Target environment'
        required: true
        type: string
      operation:
        description: 'Secret operation to perform'
        required: false
        type: string
        default: 'validate-secrets'
      deploy_new_secrets:
        description: 'Deploy new secrets after validation'
        required: false
        type: boolean
        default: false
  workflow_dispatch:
    inputs:
      operation:
        description: 'Secret management operation'
        required: true
        type: choice
        options:
          - validate-secrets
          - update-secrets
          - health-check
          - rotate-api-keys
          - backup-secrets
      environment:
        description: 'Environment (staging/production)'
        required: true
        type: choice
        default: 'staging'
        options:
          - staging
          - production
      secret_name:
        description: 'Specific secret name (optional)'
        required: false
        type: string
      dry_run:
        description: 'Dry run mode (no changes made)'
        required: false
        type: boolean
        default: true

env:
  AWS_REGION: ap-southeast-1
  NODE_VERSION: 18

jobs:
  # Job 0: Detect secret changes and new secrets
  detect-secret-changes:
    name: Detect Secret Infrastructure Changes
    runs-on: ubuntu-latest
    if: github.event_name == 'push' || github.event_name == 'pull_request' || github.event_name == 'workflow_call'
    outputs:
      secrets_changed: ${{ steps.detect.outputs.secrets_changed }}
      new_secrets_detected: ${{ steps.detect.outputs.new_secrets_detected }}
      environments_affected: ${{ steps.detect.outputs.environments_affected }}
      should_deploy: ${{ steps.detect.outputs.should_deploy }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: Install dependencies
        run: |
          cd infrastructure
          npm ci

      - name: Detect secret infrastructure changes
        id: detect
        run: |
          echo "üîç Detecting secret infrastructure changes..."
          
          SECRETS_CHANGED=false
          NEW_SECRETS_DETECTED=false
          ENVIRONMENTS_AFFECTED=""
          SHOULD_DEPLOY=false
          
          # Check if this is a manual trigger or workflow call
          if [ "${{ github.event_name }}" = "workflow_dispatch" ] || [ "${{ github.event_name }}" = "workflow_call" ]; then
            echo "Manual trigger detected - proceeding with validation"
            SECRETS_CHANGED=true
            SHOULD_DEPLOY=true
            
            if [ "${{ github.event.inputs.environment || inputs.environment }}" != "" ]; then
              ENVIRONMENTS_AFFECTED="${{ github.event.inputs.environment || inputs.environment }}"
            else
              ENVIRONMENTS_AFFECTED="staging,production"
            fi
          elif [ "${{ github.event_name }}" = "schedule" ]; then
            echo "Scheduled health check - validating all environments"
            SECRETS_CHANGED=true
            ENVIRONMENTS_AFFECTED="staging,production"
          elif [ "${{ github.event_name }}" = "push" ] || [ "${{ github.event_name }}" = "pull_request" ]; then
            # Detect changes in infrastructure files
            if [ "${{ github.event_name }}" = "push" ]; then
              CHANGED_FILES=$(git diff --name-only HEAD^ HEAD || git diff --name-only HEAD~1 HEAD)
            else
              CHANGED_FILES=$(git diff --name-only origin/main...HEAD)
            fi
            
            echo "üìÅ Changed files:"
            echo "$CHANGED_FILES"
            
            # Check for secret-related changes
            SECRET_FILES=$(echo "$CHANGED_FILES" | grep -E "(secrets-stack|production-stack|config/)" || true)
            
            if [ -n "$SECRET_FILES" ]; then
              echo "üîí Secret-related changes detected:"
              echo "$SECRET_FILES"
              SECRETS_CHANGED=true
              SHOULD_DEPLOY=${{ github.event_name == 'push' && github.ref == 'refs/heads/main' }}
              
              # Analyze which environments might be affected
              cd infrastructure
              
              # Check for new secret definitions in CDK code
              for env in staging production; do
                echo "Checking environment: $env"
                
                # Synthesize CDK to see what secrets would be created
                if npx cdk synth "NameCardSecrets-$env" --context "environment=$env" > "/tmp/secrets-$env.json" 2>/dev/null; then
                  # Extract secret names from template
                  NEW_SECRETS=$(jq -r '.Resources | to_entries[] | select(.value.Type == "AWS::SecretsManager::Secret") | .key' "/tmp/secrets-$env.json" 2>/dev/null || echo "")
                  
                  if [ -n "$NEW_SECRETS" ]; then
                    echo "üì¶ Potential new secrets for $env:"
                    echo "$NEW_SECRETS"
                    
                    # Check if these secrets already exist in AWS
                    for secret_logical_id in $NEW_SECRETS; do
                      # Try to map logical ID to actual secret name
                      SECRET_NAME=$(jq -r ".Resources.${secret_logical_id}.Properties.Name // empty" "/tmp/secrets-$env.json" 2>/dev/null)
                      
                      if [ -n "$SECRET_NAME" ] && [ "$SECRET_NAME" != "null" ]; then
                        echo "Checking if secret exists: $SECRET_NAME"
                        
                        if ! aws secretsmanager describe-secret --secret-id "$SECRET_NAME" --region ${{ env.AWS_REGION }} > /dev/null 2>&1; then
                          echo "üÜï New secret detected: $SECRET_NAME"
                          NEW_SECRETS_DETECTED=true
                          
                          if [ -z "$ENVIRONMENTS_AFFECTED" ]; then
                            ENVIRONMENTS_AFFECTED="$env"
                          else
                            ENVIRONMENTS_AFFECTED="$ENVIRONMENTS_AFFECTED,$env"
                          fi
                        fi
                      fi
                    done
                  fi
                else
                  echo "‚ö†Ô∏è  Could not synthesize CDK for environment: $env"
                fi
              done
            else
              echo "‚úÖ No secret-related changes detected"
            fi
          fi
          
          echo "secrets_changed=$SECRETS_CHANGED" >> $GITHUB_OUTPUT
          echo "new_secrets_detected=$NEW_SECRETS_DETECTED" >> $GITHUB_OUTPUT
          echo "environments_affected=$ENVIRONMENTS_AFFECTED" >> $GITHUB_OUTPUT
          echo "should_deploy=$SHOULD_DEPLOY" >> $GITHUB_OUTPUT
          
          echo ""
          echo "üìä DETECTION SUMMARY"
          echo "==================="
          echo "Secrets changed: $SECRETS_CHANGED"
          echo "New secrets detected: $NEW_SECRETS_DETECTED"  
          echo "Environments affected: $ENVIRONMENTS_AFFECTED"
          echo "Should deploy: $SHOULD_DEPLOY"

  # Job 1: Deploy new secrets infrastructure
  deploy-new-secrets:
    name: Deploy New Secrets Infrastructure
    runs-on: ubuntu-latest
    needs: detect-secret-changes
    if: needs.detect-secret-changes.outputs.new_secrets_detected == 'true' && needs.detect-secret-changes.outputs.should_deploy == 'true'
    
    strategy:
      matrix:
        environment: ${{ fromJson(format('["{0}"]', needs.detect-secret-changes.outputs.environments_affected)) }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: Install dependencies
        run: |
          cd infrastructure
          npm ci

      - name: Deploy secrets stack
        run: |
          echo "üöÄ Deploying secrets stack for environment: ${{ matrix.environment }}"
          
          cd infrastructure
          
          # Deploy the secrets stack
          npx cdk deploy "NameCardSecrets-${{ matrix.environment }}" \
            --context "environment=${{ matrix.environment }}" \
            --require-approval never \
            --outputs-file "secrets-outputs-${{ matrix.environment }}.json"
          
          echo "‚úÖ Secrets stack deployed successfully for ${{ matrix.environment }}"

      - name: Validate deployed secrets
        run: |
          echo "üîç Validating newly deployed secrets for ${{ matrix.environment }}..."
          
          # Wait a moment for secrets to be available
          sleep 10
          
          # Use our secret management script to validate
          cd ${{ github.workspace }}
          ./scripts/secret-management.sh validate "${{ matrix.environment }}"
          
          echo "‚úÖ Secret validation completed for ${{ matrix.environment }}"

  # Job 2: Secret validation and health checks
  validate-secrets:
    name: Validate Secrets Configuration
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request' || (github.event_name == 'workflow_dispatch' && github.event.inputs.operation == 'validate-secrets')
    outputs:
      validation_status: ${{ steps.validate.outputs.status }}
      secrets_healthy: ${{ steps.validate.outputs.healthy }}
      validation_report: ${{ steps.validate.outputs.report }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: Install dependencies
        run: |
          cd infrastructure
          npm ci

      - name: Validate secret schema and configuration
        id: validate
        run: |
          echo "üîç Validating secrets configuration..."
          ENVIRONMENT="${{ github.event.inputs.environment || 'staging' }}"
          
          # Validate CDK secret stack configuration
          cd infrastructure
          npx cdk synth NameCardSecrets-$ENVIRONMENT --context environment=$ENVIRONMENT > /tmp/secrets-template.json
          
          if [ $? -eq 0 ]; then
            echo "‚úÖ CDK secret stack synthesis successful"
            echo "status=success" >> $GITHUB_OUTPUT
          else
            echo "‚ùå CDK secret stack synthesis failed"
            echo "status=failed" >> $GITHUB_OUTPUT
            exit 1
          fi
          
          # Check if secrets exist in AWS Secrets Manager
          echo "üîí Checking AWS Secrets Manager..."
          
          SECRETS_STATUS="healthy"
          VALIDATION_REPORT=""
          
          # Define expected secrets for the environment
          declare -a EXPECTED_SECRETS=(
            "namecard/database/$ENVIRONMENT"
            "namecard/api/$ENVIRONMENT"
          )
          
          for secret in "${EXPECTED_SECRETS[@]}"; do
            echo "Checking secret: $secret"
            
            if aws secretsmanager describe-secret --secret-id "$secret" --region ${{ env.AWS_REGION }} > /dev/null 2>&1; then
              echo "‚úÖ Secret exists: $secret"
              VALIDATION_REPORT="${VALIDATION_REPORT}‚úÖ $secret: EXISTS\\n"
              
              # Validate secret can be retrieved
              if aws secretsmanager get-secret-value --secret-id "$secret" --region ${{ env.AWS_REGION }} --query 'SecretString' --output text > /dev/null 2>&1; then
                echo "‚úÖ Secret accessible: $secret"
                VALIDATION_REPORT="${VALIDATION_REPORT}‚úÖ $secret: ACCESSIBLE\\n"
              else
                echo "‚ùå Secret not accessible: $secret"
                VALIDATION_REPORT="${VALIDATION_REPORT}‚ùå $secret: NOT ACCESSIBLE\\n"
                SECRETS_STATUS="unhealthy"
              fi
            else
              echo "‚ùå Secret missing: $secret"
              VALIDATION_REPORT="${VALIDATION_REPORT}‚ùå $secret: MISSING\\n"
              SECRETS_STATUS="unhealthy"
            fi
          done
          
          echo "healthy=$SECRETS_STATUS" >> $GITHUB_OUTPUT
          echo "report<<EOF" >> $GITHUB_OUTPUT
          echo -e "$VALIDATION_REPORT" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
          
          if [ "$SECRETS_STATUS" = "healthy" ]; then
            echo "‚úÖ All secrets validation passed"
          else
            echo "‚ùå Secret validation failed"
            exit 1
          fi

      - name: Test secret connectivity
        run: |
          echo "üîó Testing secret connectivity..."
          ENVIRONMENT="${{ github.event.inputs.environment || 'staging' }}"
          
          # Test database secret
          DB_SECRET=$(aws secretsmanager get-secret-value --secret-id "namecard/database/$ENVIRONMENT" --region ${{ env.AWS_REGION }} --query 'SecretString' --output text)
          DB_HOST=$(echo "$DB_SECRET" | jq -r '.host // empty')
          
          if [ -n "$DB_HOST" ] && [ "$DB_HOST" != "null" ]; then
            echo "‚úÖ Database secret structure valid - host: $DB_HOST"
          else
            echo "‚ùå Database secret missing required 'host' field"
            exit 1
          fi
          
          # Test API secret
          API_SECRET=$(aws secretsmanager get-secret-value --secret-id "namecard/api/$ENVIRONMENT" --region ${{ env.AWS_REGION }} --query 'SecretString' --output text)
          JWT_SECRET=$(echo "$API_SECRET" | jq -r '.JWT_SECRET // empty')
          
          if [ -n "$JWT_SECRET" ] && [ "$JWT_SECRET" != "null" ]; then
            echo "‚úÖ API secret structure valid - JWT_SECRET present"
          else
            echo "‚ùå API secret missing required 'JWT_SECRET' field"
            exit 1
          fi
          
          echo "‚úÖ All secret connectivity tests passed"

  # Job 2: Secret health monitoring
  health-check:
    name: Secret Health Check
    runs-on: ubuntu-latest
    if: github.event_name == 'workflow_dispatch' && github.event.inputs.operation == 'health-check'
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Comprehensive secret health check
        run: |
          echo "üè• Performing comprehensive secret health check..."
          ENVIRONMENT="${{ github.event.inputs.environment }}"
          
          # Function to check secret health
          check_secret_health() {
            local secret_name="$1"
            local secret_type="$2"
            
            echo "üîç Checking health of secret: $secret_name"
            
            # Check if secret exists
            if ! aws secretsmanager describe-secret --secret-id "$secret_name" --region ${{ env.AWS_REGION }} > /dev/null 2>&1; then
              echo "‚ùå Secret does not exist: $secret_name"
              return 1
            fi
            
            # Get secret metadata
            SECRET_META=$(aws secretsmanager describe-secret --secret-id "$secret_name" --region ${{ env.AWS_REGION }})
            LAST_CHANGED=$(echo "$SECRET_META" | jq -r '.LastChangedDate')
            LAST_ACCESSED=$(echo "$SECRET_META" | jq -r '.LastAccessedDate // "Never"')
            
            echo "üìÖ Last changed: $LAST_CHANGED"
            echo "üìÖ Last accessed: $LAST_ACCESSED"
            
            # Check secret age (warn if older than 90 days)
            if [ "$LAST_CHANGED" != "null" ]; then
              LAST_CHANGED_EPOCH=$(date -d "$LAST_CHANGED" +%s 2>/dev/null || echo "0")
              CURRENT_EPOCH=$(date +%s)
              AGE_DAYS=$(( (CURRENT_EPOCH - LAST_CHANGED_EPOCH) / 86400 ))
              
              echo "üìä Secret age: $AGE_DAYS days"
              
              if [ $AGE_DAYS -gt 90 ]; then
                echo "‚ö†Ô∏è  WARNING: Secret is older than 90 days - consider rotation"
              else
                echo "‚úÖ Secret age is acceptable"
              fi
            fi
            
            # Test secret retrieval
            if aws secretsmanager get-secret-value --secret-id "$secret_name" --region ${{ env.AWS_REGION }} --query 'SecretString' --output text > /dev/null 2>&1; then
              echo "‚úÖ Secret retrieval successful"
            else
              echo "‚ùå Secret retrieval failed"
              return 1
            fi
            
            # Validate secret structure based on type
            SECRET_VALUE=$(aws secretsmanager get-secret-value --secret-id "$secret_name" --region ${{ env.AWS_REGION }} --query 'SecretString' --output text)
            
            case $secret_type in
              "database")
                if echo "$SECRET_VALUE" | jq -e '.host and .username and .password and .dbname' > /dev/null; then
                  echo "‚úÖ Database secret structure valid"
                else
                  echo "‚ùå Database secret missing required fields"
                  return 1
                fi
                ;;
              "api")
                if echo "$SECRET_VALUE" | jq -e '.JWT_SECRET' > /dev/null; then
                  echo "‚úÖ API secret structure valid"
                else
                  echo "‚ùå API secret missing required fields"
                  return 1
                fi
                ;;
            esac
            
            echo "‚úÖ Secret health check passed: $secret_name"
            return 0
          }
          
          # Check all environment secrets
          OVERALL_HEALTH="healthy"
          
          echo "üîí Checking database secret..."
          if ! check_secret_health "namecard/database/$ENVIRONMENT" "database"; then
            OVERALL_HEALTH="unhealthy"
          fi
          
          echo "üîí Checking API secret..."
          if ! check_secret_health "namecard/api/$ENVIRONMENT" "api"; then
            OVERALL_HEALTH="unhealthy"
          fi
          
          # Generate health summary
          echo ""
          echo "üìä SECRET HEALTH SUMMARY"
          echo "========================="
          echo "Environment: $ENVIRONMENT"
          echo "Overall Status: $OVERALL_HEALTH"
          echo "Timestamp: $(date -u '+%Y-%m-%d %H:%M:%S UTC')"
          
          if [ "$OVERALL_HEALTH" = "healthy" ]; then
            echo "‚úÖ All secrets are healthy"
          else
            echo "‚ùå One or more secrets have health issues"
            exit 1
          fi

  # Job 3: Secret update and rotation
  update-secrets:
    name: Update Secrets
    runs-on: ubuntu-latest
    if: github.event_name == 'workflow_dispatch' && github.event.inputs.operation == 'update-secrets'
    environment: ${{ github.event.inputs.environment }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: Install dependencies
        run: |
          cd infrastructure
          npm ci

      - name: Update secrets infrastructure
        run: |
          echo "üîÑ Updating secrets infrastructure..."
          ENVIRONMENT="${{ github.event.inputs.environment }}"
          DRY_RUN="${{ github.event.inputs.dry_run }}"
          
          cd infrastructure
          
          if [ "$DRY_RUN" = "true" ]; then
            echo "üß™ DRY RUN MODE - No actual changes will be made"
            
            # Synthesize and show diff
            echo "üìã Synthesizing secrets stack..."
            npx cdk synth NameCardSecrets-$ENVIRONMENT --context environment=$ENVIRONMENT
            
            # Show what would be deployed
            echo "üìä Showing deployment diff..."
            npx cdk diff NameCardSecrets-$ENVIRONMENT --context environment=$ENVIRONMENT
          else
            echo "üöÄ LIVE DEPLOYMENT - Making actual changes"
            
            # Deploy secrets stack
            echo "üîß Deploying secrets stack updates..."
            npx cdk deploy NameCardSecrets-$ENVIRONMENT \
              --context environment=$ENVIRONMENT \
              --require-approval never \
              --outputs-file secrets-outputs.json
            
            echo "‚úÖ Secrets infrastructure updated successfully"
          fi

      - name: Validate updated secrets
        if: github.event.inputs.dry_run != 'true'
        run: |
          echo "üîç Validating updated secrets..."
          ENVIRONMENT="${{ github.event.inputs.environment }}"
          
          # Re-run validation tests
          declare -a SECRETS=(
            "namecard/database/$ENVIRONMENT"
            "namecard/api/$ENVIRONMENT"
          )
          
          for secret in "${SECRETS[@]}"; do
            if aws secretsmanager get-secret-value --secret-id "$secret" --region ${{ env.AWS_REGION }} > /dev/null 2>&1; then
              echo "‚úÖ Updated secret accessible: $secret"
            else
              echo "‚ùå Updated secret not accessible: $secret"
              exit 1
            fi
          done
          
          echo "‚úÖ All updated secrets validated successfully"

  # Job 4: API key rotation
  rotate-api-keys:
    name: Rotate API Keys
    runs-on: ubuntu-latest
    if: github.event_name == 'workflow_dispatch' && github.event.inputs.operation == 'rotate-api-keys'
    environment: ${{ github.event.inputs.environment }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Rotate JWT secret
        run: |
          echo "üîÑ Rotating JWT secret..."
          ENVIRONMENT="${{ github.event.inputs.environment }}"
          DRY_RUN="${{ github.event.inputs.dry_run }}"
          
          if [ "$DRY_RUN" = "true" ]; then
            echo "üß™ DRY RUN MODE - Would generate new JWT secret"
            NEW_JWT_SECRET=$(openssl rand -base64 32)
            echo "‚ú® New JWT secret would be: ${NEW_JWT_SECRET:0:8}..."
          else
            echo "üîß Generating new JWT secret..."
            
            # Generate new JWT secret
            NEW_JWT_SECRET=$(openssl rand -base64 32)
            echo "‚ú® Generated new JWT secret: ${NEW_JWT_SECRET:0:8}..."
            
            # Get current API secret
            CURRENT_SECRET=$(aws secretsmanager get-secret-value --secret-id "namecard/api/$ENVIRONMENT" --region ${{ env.AWS_REGION }} --query 'SecretString' --output text)
            
            # Update JWT_SECRET while preserving other fields
            UPDATED_SECRET=$(echo "$CURRENT_SECRET" | jq --arg jwt "$NEW_JWT_SECRET" '.JWT_SECRET = $jwt')
            
            # Update the secret in AWS Secrets Manager
            aws secretsmanager update-secret \
              --secret-id "namecard/api/$ENVIRONMENT" \
              --secret-string "$UPDATED_SECRET" \
              --description "JWT secret rotated on $(date -u '+%Y-%m-%d %H:%M:%S UTC')" \
              --region ${{ env.AWS_REGION }}
            
            echo "‚úÖ JWT secret rotated successfully"
            
            # Trigger ECS service restart to pick up new secret
            echo "üîÑ Restarting ECS service to apply new secret..."
            aws ecs update-service \
              --cluster "namecard-cluster-$ENVIRONMENT" \
              --service "namecard-api-$ENVIRONMENT" \
              --force-new-deployment \
              --region ${{ env.AWS_REGION }}
            
            echo "‚úÖ ECS service restart initiated"
          fi

  # Job 5: Secret backup
  backup-secrets:
    name: Backup Secrets Metadata
    runs-on: ubuntu-latest
    if: github.event_name == 'workflow_dispatch' && github.event.inputs.operation == 'backup-secrets'
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Backup secret metadata
        run: |
          echo "üíæ Backing up secret metadata..."
          ENVIRONMENT="${{ github.event.inputs.environment }}"
          
          # Create backup directory
          mkdir -p secret-backups
          BACKUP_FILE="secret-backups/secrets-metadata-$ENVIRONMENT-$(date +%Y%m%d-%H%M%S).json"
          
          # Get all secrets with namecard prefix
          SECRETS=$(aws secretsmanager list-secrets \
            --filters Key=name,Values=namecard \
            --region ${{ env.AWS_REGION }} \
            --query 'SecretList[?contains(Name, `'$ENVIRONMENT'`)]')
          
          # Create backup object with metadata only (no secret values)
          BACKUP_DATA=$(echo "$SECRETS" | jq '{
            backup_timestamp: "'$(date -u '+%Y-%m-%d %H:%M:%S UTC')'",
            environment: "'$ENVIRONMENT'",
            region: "'${{ env.AWS_REGION }}'",
            secrets: [.[] | {
              name: .Name,
              description: .Description,
              created_date: .CreatedDate,
              last_changed_date: .LastChangedDate,
              last_accessed_date: .LastAccessedDate,
              version_id: .VersionId,
              tags: .Tags
            }]
          }')
          
          # Save backup
          echo "$BACKUP_DATA" > "$BACKUP_FILE"
          
          echo "‚úÖ Secret metadata backup created: $BACKUP_FILE"
          echo "üìä Backup summary:"
          echo "$BACKUP_DATA" | jq '.secrets | length' | xargs echo "- Number of secrets:"
          echo "$BACKUP_DATA" | jq -r '.secrets[].name' | xargs -I {} echo "- {}"

      - name: Upload backup artifact
        uses: actions/upload-artifact@v4
        with:
          name: secret-metadata-backup-${{ github.event.inputs.environment }}-${{ github.run_number }}
          path: secret-backups/
          retention-days: 30

  # Job 6: Secret deployment workflow integration
  deploy-with-secrets:
    name: Deploy with Secret Validation
    runs-on: ubuntu-latest
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    needs: validate-secrets
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Deploy secrets stack updates
        run: |
          echo "üöÄ Deploying secrets stack updates..."
          
          cd infrastructure
          npm ci
          
          # Deploy to staging first
          echo "üì¶ Deploying to staging..."
          npx cdk deploy NameCardSecrets-staging \
            --context environment=staging \
            --require-approval never
          
          echo "‚úÖ Secrets deployed to staging successfully"

  # Job 7: Generate deployment report
  generate-report:
    name: Generate Secret Management Report
    runs-on: ubuntu-latest
    if: always() && github.event_name == 'workflow_dispatch'
    needs: [validate-secrets, health-check, update-secrets, rotate-api-keys, backup-secrets]
    
    steps:
      - name: Generate comprehensive report
        run: |
          echo "üìä SECRET MANAGEMENT WORKFLOW REPORT"
          echo "===================================="
          echo "Timestamp: $(date -u '+%Y-%m-%d %H:%M:%S UTC')"
          echo "Operation: ${{ github.event.inputs.operation }}"
          echo "Environment: ${{ github.event.inputs.environment }}"
          echo "Dry Run: ${{ github.event.inputs.dry_run }}"
          echo "Triggered by: ${{ github.actor }}"
          echo ""
          
          # Job results
          echo "üìã Job Results:"
          echo "- Validate Secrets: ${{ needs.validate-secrets.result || 'SKIPPED' }}"
          echo "- Health Check: ${{ needs.health-check.result || 'SKIPPED' }}"
          echo "- Update Secrets: ${{ needs.update-secrets.result || 'SKIPPED' }}"
          echo "- Rotate API Keys: ${{ needs.rotate-api-keys.result || 'SKIPPED' }}"
          echo "- Backup Secrets: ${{ needs.backup-secrets.result || 'SKIPPED' }}"
          echo ""
          
          # Overall status
          OVERALL_SUCCESS=true
          for job in "${{ needs.validate-secrets.result }}" "${{ needs.health-check.result }}" "${{ needs.update-secrets.result }}" "${{ needs.rotate-api-keys.result }}" "${{ needs.backup-secrets.result }}"; do
            if [ "$job" = "failure" ]; then
              OVERALL_SUCCESS=false
              break
            fi
          done
          
          if [ "$OVERALL_SUCCESS" = true ]; then
            echo "‚úÖ Overall Status: SUCCESS"
            echo "üéâ All secret management operations completed successfully!"
          else
            echo "‚ùå Overall Status: FAILURE"
            echo "üí• One or more secret management operations failed. Please review the logs."
          fi
          
          echo ""
          echo "üîó Workflow URL: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"