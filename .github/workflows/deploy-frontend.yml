name: Deploy Frontend

on:
  push:
    branches: [cicd-pipeline-setup, main]
    paths:
      - 'packages/web/**'
      - '.github/workflows/deploy-frontend.yml'
      - 'infrastructure/lib/frontend-stack.ts'
  workflow_dispatch:
    inputs:
      force_deploy:
        description: 'Force deploy frontend even without changes'
        required: false
        default: 'false'
        type: boolean
      environment:
        description: 'Environment to deploy to'
        required: false
        default: 'staging'
        type: choice
        options:
        - staging
        - production

env:
  AWS_REGION: ap-southeast-1
  NODE_VERSION: 18

jobs:
  detect-changes:
    name: Detect Frontend Changes
    runs-on: ubuntu-latest
    outputs:
      frontend_changed: ${{ steps.changes.outputs.frontend_changed }}
      should_deploy: ${{ steps.decision.outputs.should_deploy }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 2

      - name: Detect frontend changes
        id: changes
        run: |
          echo "üîç Detecting frontend changes..."
          
          # Check if this is a manual trigger
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            echo "Manual workflow trigger detected"
            echo "frontend_changed=manual" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          # Check for frontend-related changes
          FRONTEND_CHANGED=$(git diff --name-only HEAD^ HEAD | grep -E "(packages/web/|\.github/workflows/deploy-frontend\.yml|infrastructure/lib/frontend-stack\.ts)" || echo "")
          
          if [ -n "$FRONTEND_CHANGED" ]; then
            echo "frontend_changed=true" >> $GITHUB_OUTPUT
            echo "üì¶ Frontend changes detected:"
            echo "$FRONTEND_CHANGED"
          else
            echo "frontend_changed=false" >> $GITHUB_OUTPUT
            echo "‚úÖ No frontend changes detected"
          fi

      - name: Deployment decision
        id: decision
        run: |
          FRONTEND_CHANGED="${{ steps.changes.outputs.frontend_changed }}"
          FORCE_DEPLOY="${{ github.event.inputs.force_deploy }}"
          
          if [ "$FRONTEND_CHANGED" = "true" ] || [ "$FRONTEND_CHANGED" = "manual" ] || [ "$FORCE_DEPLOY" = "true" ]; then
            echo "should_deploy=true" >> $GITHUB_OUTPUT
            echo "üöÄ Frontend deployment will proceed"
          else
            echo "should_deploy=false" >> $GITHUB_OUTPUT
            echo "‚è≠Ô∏è  Skipping frontend deployment - no changes detected"
          fi

  build-frontend:
    name: Build Frontend
    runs-on: ubuntu-latest
    needs: detect-changes
    if: needs.detect-changes.outputs.should_deploy == 'true'
    outputs:
      build_path: ${{ steps.build.outputs.build_path }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Build frontend
        id: build
        run: |
          echo "üèóÔ∏è  Building React frontend for production..."
          
          # Show current directory and Node version
          echo "üìÇ Current directory: $(pwd)"
          echo "üì¶ Node version: $(node --version)"
          echo "üì¶ NPM version: $(npm --version)"
          
          # Check workspace configuration
          echo "üîç Checking workspace configuration..."
          npm run build --workspace=packages/web --dry-run || true
          
          # Build dependencies first (shared package)
          echo "üî® Building shared package dependencies..."
          npm run build --workspace=packages/shared
          
          # Build the frontend with explicit workspace
          echo "üî® Starting frontend build process..."
          npm run build --workspace=packages/web
          
          # Alternative build approaches if workspace fails
          if [ ! -d "packages/web/dist" ]; then
            echo "‚ö†Ô∏è  Workspace build may have failed, trying turbo build with dependencies..."
            npx turbo build --filter=@namecard/shared
            npx turbo build --filter=@namecard/web
          fi
          
          if [ ! -d "packages/web/dist" ]; then
            echo "‚ö†Ô∏è  Turbo build may have failed, trying direct build with dependencies..."
            cd packages/shared && npm run build && cd ../web && npm run build && cd ../..
          fi
          
          # Verify build output
          if [ ! -d "packages/web/dist" ]; then
            echo "‚ùå Build failed - dist directory not found"
            echo "üîç Checking for alternative build outputs..."
            find . -name "dist" -type d || true
            find . -name "build" -type d || true
            exit 1
          fi
          
          # Check build size
          BUILD_SIZE=$(du -sh packages/web/dist | cut -f1)
          echo "üì¶ Build size: $BUILD_SIZE"
          
          # List key files
          echo "üìã Build contents:"
          ls -la packages/web/dist/
          
          # Verify essential files exist
          if [ ! -f "packages/web/dist/index.html" ]; then
            echo "‚ùå Critical file missing: index.html"
            exit 1
          fi
          
          echo "build_path=packages/web/dist" >> $GITHUB_OUTPUT
          echo "‚úÖ Frontend build completed successfully"

      - name: Upload build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: frontend-build-${{ github.sha }}
          path: packages/web/dist/
          retention-days: 7
          compression-level: 6

  deploy-frontend:
    name: Deploy Frontend to AWS
    runs-on: ubuntu-latest
    needs: [detect-changes, build-frontend]
    if: needs.detect-changes.outputs.should_deploy == 'true'
    environment: ${{ github.event.inputs.environment || 'staging' }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: Download build artifacts
        uses: actions/download-artifact@v4
        with:
          name: frontend-build-${{ github.sha }}
          path: packages/web/dist/

      - name: Install infrastructure dependencies
        run: |
          cd infrastructure
          npm ci

      - name: Get deployment configuration
        id: config
        run: |
          ENVIRONMENT="${{ github.event.inputs.environment || 'staging' }}"
          echo "environment=$ENVIRONMENT" >> $GITHUB_OUTPUT
          
          # Set environment-specific configurations
          case $ENVIRONMENT in
            staging)
              echo "stack_name=NameCardFrontend-staging" >> $GITHUB_OUTPUT
              echo "api_url=http://NameCa-APISe-N5y96ivnIVEm-949793622.ap-southeast-1.elb.amazonaws.com" >> $GITHUB_OUTPUT
              ;;
            production)
              echo "stack_name=NameCardFrontend-production" >> $GITHUB_OUTPUT
              echo "api_url=https://api.namecard.app" >> $GITHUB_OUTPUT
              ;;
            *)
              echo "‚ùå Invalid environment: $ENVIRONMENT"
              exit 1
              ;;
          esac

      - name: Deploy frontend infrastructure
        run: |
          echo "üèóÔ∏è  Deploying frontend infrastructure..."
          cd infrastructure
          
          npx cdk deploy ${{ steps.config.outputs.stack_name }} \
            --context environment=${{ steps.config.outputs.environment }} \
            --context apiUrl=${{ steps.config.outputs.api_url }} \
            --require-approval never \
            --outputs-file frontend-outputs.json
          
          echo "‚úÖ Frontend infrastructure deployed"

      - name: Get S3 bucket and CloudFront distribution
        id: resources
        run: |
          cd infrastructure
          
          # Extract values from CDK outputs
          BUCKET_NAME=$(jq -r '.["${{ steps.config.outputs.stack_name }}"].FrontendBucketName // empty' frontend-outputs.json)
          DISTRIBUTION_ID=$(jq -r '.["${{ steps.config.outputs.stack_name }}"].FrontendDistributionId // empty' frontend-outputs.json)
          FRONTEND_URL=$(jq -r '.["${{ steps.config.outputs.stack_name }}"].FrontendUrl // empty' frontend-outputs.json)
          
          if [ -z "$BUCKET_NAME" ] || [ "$BUCKET_NAME" = "null" ]; then
            echo "‚ùå Could not get S3 bucket name from CDK outputs"
            exit 1
          fi
          
          if [ -z "$DISTRIBUTION_ID" ] || [ "$DISTRIBUTION_ID" = "null" ]; then
            echo "‚ùå Could not get CloudFront distribution ID from CDK outputs"
            exit 1
          fi
          
          echo "bucket_name=$BUCKET_NAME" >> $GITHUB_OUTPUT
          echo "distribution_id=$DISTRIBUTION_ID" >> $GITHUB_OUTPUT
          echo "frontend_url=$FRONTEND_URL" >> $GITHUB_OUTPUT
          
          echo "üì¶ S3 Bucket: $BUCKET_NAME"
          echo "üåê CloudFront Distribution: $DISTRIBUTION_ID"
          echo "üîó Frontend URL: $FRONTEND_URL"

      - name: Sync files to S3
        run: |
          echo "üì§ Syncing frontend files to S3..."
          
          # Sync with appropriate cache headers
          aws s3 sync packages/web/dist/ s3://${{ steps.resources.outputs.bucket_name }}/ \
            --delete \
            --cache-control "public,max-age=86400" \
            --exclude "*.html" \
            --region ${{ env.AWS_REGION }}
          
          # Upload HTML files with no cache
          aws s3 sync packages/web/dist/ s3://${{ steps.resources.outputs.bucket_name }}/ \
            --delete \
            --cache-control "public,max-age=0,must-revalidate" \
            --include "*.html" \
            --region ${{ env.AWS_REGION }}
          
          echo "‚úÖ Files synced to S3"

      - name: Invalidate CloudFront cache
        run: |
          echo "üîÑ Invalidating CloudFront cache..."
          
          INVALIDATION_ID=$(aws cloudfront create-invalidation \
            --distribution-id ${{ steps.resources.outputs.distribution_id }} \
            --paths "/*" \
            --query 'Invalidation.Id' \
            --output text \
            --region ${{ env.AWS_REGION }})
          
          echo "üìã Invalidation ID: $INVALIDATION_ID"
          
          # Wait for invalidation to complete (optional, but good for verification)
          echo "‚è≥ Waiting for cache invalidation to complete..."
          aws cloudfront wait invalidation-completed \
            --distribution-id ${{ steps.resources.outputs.distribution_id }} \
            --id $INVALIDATION_ID \
            --region ${{ env.AWS_REGION }}
          
          echo "‚úÖ CloudFront cache invalidated"

      - name: Verify deployment
        run: |
          FRONTEND_URL="${{ steps.resources.outputs.frontend_url }}"
          
          if [ -z "$FRONTEND_URL" ] || [ "$FRONTEND_URL" = "null" ]; then
            echo "‚ö†Ô∏è  Could not get frontend URL from outputs"
            exit 1
          fi
          
          echo "üîç Testing frontend deployment..."
          
          # Health check with retry
          for i in {1..10}; do
            response=$(curl -s -o /dev/null -w "%{http_code}" "$FRONTEND_URL" || echo "000")
            
            if [ "$response" = "200" ]; then
              echo "‚úÖ Frontend deployment successful!"
              echo "üöÄ Frontend available at: $FRONTEND_URL"
              
              # Test API proxy
              echo "üîó Testing API proxy..."
              api_response=$(curl -s -o /dev/null -w "%{http_code}" "$FRONTEND_URL/api/v1/" || echo "000")
              if [ "$api_response" = "200" ]; then
                echo "‚úÖ API proxy working correctly"
              else
                echo "‚ö†Ô∏è  API proxy returned: $api_response"
              fi
              exit 0
            else
              echo "Attempt $i: HTTP status $response, retrying in 10 seconds..."
              sleep 10
            fi
          done
          
          echo "‚ùå Frontend health check failed after 10 attempts. Final HTTP status: $response"
          exit 1

      - name: Update deployment status
        if: always()
        run: |
          if [ "${{ job.status }}" = "success" ]; then
            echo "üéâ Frontend deployment completed successfully!"
            echo "üîó Frontend URL: ${{ steps.resources.outputs.frontend_url }}"
          else
            echo "üí• Frontend deployment failed. Please check the logs."
          fi

  notify:
    name: Notify Deployment Status
    runs-on: ubuntu-latest
    needs: [detect-changes, deploy-frontend]
    if: always() && needs.detect-changes.outputs.should_deploy == 'true'
    steps:
      - name: Deployment summary
        run: |
          echo "üìä Frontend Deployment Summary"
          echo "=============================="
          echo "Environment: ${{ github.event.inputs.environment || 'staging' }}"
          echo "Branch: ${{ github.ref_name }}"
          echo "Commit: ${{ github.sha }}"
          echo "Status: ${{ needs.deploy-frontend.result }}"
          
          if [ "${{ needs.deploy-frontend.result }}" = "success" ]; then
            echo "‚úÖ Deployment successful"
          else
            echo "‚ùå Deployment failed"
          fi